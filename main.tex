\documentclass{article}
\usepackage[utf8]{inputenc}

\title{An introduction to that which shall not be named\footnote{These lecture notes were for the Computational Logic Center Seminar at the University of Iowa.}}
\author{Harley Eades III\\Computer Science\\Augusta University\\\href{mailto:heades@augusta.edu}{heades@augusta.edu}}
\date{September 2016}

\usepackage{amsthm, amsmath, amssymb}
\usepackage{mathpartir}
\usepackage{mdframed}           % For the boxes around the systems.
\usepackage[barr]{xy}
\usepackage{fullpage}
\input{type-theory_inc}
%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

\usepackage{proof}
\usepackage{enumerate}
\usepackage{todonotes}
\usepackage{hyperref}

\let\b\relax
\let\d\relax
\let\t\relax

\newcommand{\F}{\mathop{\textbf{F}}}
\renewcommand{\P}{\mathop{\textbf{P}}}
\newcommand{\G}{\mathop{\textbf{G}}}
\renewcommand{\H}{\mathop{\textbf{H}}}

\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\pd}[0]{\times}
\newcommand{\ihom}[0]{\rightarrow}
\newcommand{\st}[2]{\mathsf{st}_{#1,#2}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\b}[1]{\mathsf{b}_{#1}}
\newcommand{\d}[1]{\mathsf{d}_{#1}}
\newcommand{\m}[1]{\mathsf{m}_{#1}}
\newcommand{\n}[1]{\mathsf{n}_{#1}}
\newcommand{\p}[1]{\mathsf{p}_{#1}}
\newcommand{\q}[1]{\mathsf{q}_{#1}}
\newcommand{\t}[0]{\mathsf{t}}
\newcommand{\limp}[0]{\multimap}
\newcommand{\Hom}[3]{\mathsf{Hom}_{#1}(#2,#3)}

\def\cW{\color{white}}

%% Begin Ott
\input{lambdaT-inc}
\renewcommand{\Ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,#4}}
\renewcommand{\OttdrulevarName}[0]{\text{var}}
\renewcommand{\OttdruletrivName}[0]{1_i}
\renewcommand{\OttdrulepairName}[0]{\times_i}
\renewcommand{\OttdrulefirstName}[0]{\times_{e_1}}
\renewcommand{\OttdrulesecondName}[0]{\times_{e_2}}
\renewcommand{\OttdrulelambdaName}[0]{\lambda_i}
\renewcommand{\OttdruleappName}[0]{\lambda_e}
\renewcommand{\OttdrulereturnName}[0]{T_i}
\renewcommand{\OttdrulebindName}[0]{T_e}
%% End Ott
                                   
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{notn}[theorem]{Notation}
\newtheorem{observation}[theorem]{Observation}

\begin{document}

\maketitle

\section{A quick overview from programming}
\label{sec:a_quick_example_from_programming}
Consider a C program with signature \verb!int f(int)!.  Now describe
all possible computations this program can do.  This is a difficult
task, because this function could do a lot, like, prompt the user for
input, send packets across the network, modify global state, and much
more, but then eventually return an integer.

Now consider a purely functional programming language like Haskell
\cite{Haskell} and list all the possible computations the function
\verb!f :: Int -> Int! can do. The list is a lot smaller.  We know
without a doubt that this function must take an integer as an input,
and then do integer computations, and finally return an integer.  No
funny business went on inside this function.  Thus, reasoning about
pure programs is a lot easier.

However, a practical programmer might now be asking, ``How do we get
any real work done in a pure setting?''.  From stage left enters the
monad.  These allow for a programmer to annotate the return types of
functions to indicate which side effects the function will use.  For
example, say we wanted \verb!f! to use a global state of integers,
then its type would be \verb!f :: Int -> State [Int] Int! to indicate
that \verb!f! will take in an integer input, then during computation
will use a global state consisting of a list of integers, but then
eventually return an integer.  Thus, the return type of \verb!f!
  literally lists the side effects the function will use.  Now while
  reasoning about programs we know exactly which side effects to
  consider.

In full generality a monad is a type constructor \verb!m : * -> *!
where \verb!*! is the universe of types.  Given a type \verb!a! we
call the type \verb!m a! the type of computations returning values
of type \verb!a!.  Thus, a function \verb!f : a -> m b! is a function that
takes in values of type \verb!a!, and then returns a computation that
will eventually return a value of type \verb!b!.

Suppose we have \verb!f :: a -> m b! and \verb!g :: b -> m c!, and we
wish to apply \verb!g! to the value returned by \verb!f!. This sounds
perfectly reasonable, but ordinary composition \verb!g.f! does not
suffice, because the return type of \verb!f! is not identical to the
input type of \verb!g!.  Thus, we must come up with a new type of
composition.  To accomplish this in Haskell we first need a new
operator called \textit{bind} which is denoted by
\verb!>>= :: m b -> (b -> m c) -> m c!.  Then composition of \verb!f!
and \verb!g! can be defined by\\
\verb!\x -> ((f x) >>= g) :: a -> m c!.

So we have a composition for functions whose type has the shape
\verb!a -> m b!, but any self respecting composition has an identity.
This implies that we need some function \verb!id :: a -> m a!, such
that, $\verb!(\x -> (f x) >>= id)! = \verb!f!$ and
$\verb!(\x -> (id x) >>= g)! = \verb!g!$.  This identity is denoted by\\
\verb!return :: a -> m a! in Haskell, and has to be taken as
additional structure, because it cannot be defined in terms of bind.

Using \verb!bind! and \verb!return! in combination with products, sum
types, and higher-order functions a large number of monads can be
defined, but what are monads really?
% section a_quick_example_from_programming (end)

\section{What is a monad really?}
\label{sec:what_is_a_monad_really}
Monad's first arose in category theory and go back to Eilenberg and
MacLane \cite{MacLane:1971}, but Moggi was the first to propose that
they be used to model effectful computation in a pure setting
\cite{Moggi:1988}.  After learning about Moggi's work Wadler pushed
for their adoption by the functional programming community
\cite{jones1993glasgow,Wadler:1990:CM:91556.91592,Wadler:1992:EFP:143165.143169,Wadler:1995}. This
push resulted in the adoption of monads as the primary means of
effectful programming in Haskell.

In the most general sense a monad is defined as follows:
\begin{definition}
  \label{def:monad}
  Suppose $\cat{C}$ is a category.  Then a \textbf{monad} is a functor
  $T : \cat{C} \mto \cat{C}$ equipped with two natural transformations
  $\eta_A : A \mto T A$ and $\mu_A : T^2 A \mto TA$ such that the
  following diagrams commute:
  \[
  \begin{array}{ccc}
    \bfig
    \Square|amma|[
      T^3 A`
      T^2A`
      T^2A`
      TA;
      T\mu_A`
      \mu_{TA}`
      \mu_A`
      \mu_A]
    \efig
    & \quad &
    \bfig
    \qtriangle|amm|/->`=`->/[
      TA`
      T^2A`
      TA;
      \eta_{TA}``
      \mu_A]
    \btriangle|mma|/->`=`->/[
      TA`
      T^2A`
      TA;
      T\eta_A``
      \mu_A]
    \efig
  \end{array}
  \]
\end{definition}
From a computational perspective one should think of an object $A$ as
being the type of values, and the object $TA$ as the type of
computations.  Then $\eta_A : A \mto TA$ says that all values are
computations that eventually yield a value of type $A$, and $\mu_A :
T^2A \mto TA$ says forming the type of computations that eventually
yield a computation of type $TA$ is just as good as a computation of
type $TA$.  We can also think of $TA$ as capturing all of the possible
computations where $T^2A$ really does not add anything new.  We will
see that join allows for a very interesting form of composition to be
defined.

The diagrams above tell us how $\eta$ and $\mu$ interact together.
For example, inserting a computation of type $TA$ into the type of
computations of type $T^2A$, and then joining $T^2A$ to yield $TA$
does not do anything to the input.  That is, $\eta_{TA};\mu_A =
\id_{TA}$.  These diagrams will ensure that program evaluation behaves
correctly in the model.

Consider an example.  The functor $\mathcal{P} : \mathsf{Set} \mto
\mathsf{Set}$ defined as $\mathcal{P}(X) = \{S \subseteq X\}$.  First,
we need to check to make sure this is an endofunctor so suppose $f : A
\mto B$ is a function, then we can define $\mathcal{P}(f)(X \subseteq
A) = \{f(x) \mid x \in X \} : \mathcal{P}(A) \mto
\mathcal{P}(B)$. Suppose $f : A \mto B$ and $g : B \mto C$.  Then
composition is preserved $\mathcal{P}(f;g) =
\mathcal{P}(f);\mathcal{P}(g) : \mathcal{P}(A) \mto \mathcal{P}(C)$.  We
can also see that $\mathcal{P}(\id_A) =
\id_{\mathcal{P}(A)} : \mathcal{P}(A) \mto \mathcal{P}(A)$.

It turns out that this functor is indeed a monad:
\[
\begin{array}{lll}
  \eta_A(x) = \{x\} : A \mto \mathcal{P}(X)\\
  \mu_A(X) = \bigcup_{S \in X}S : \mathcal{P}(\mathcal{P}(A)) \mto \mathcal{P}(A)\\
\end{array}
\]
Now we must verify that the diagrams for a monad commute:
\[
\begin{array}{ccc}
  \bfig
  \Square|amma|[
    \mathcal{P}^3 (A)`
    \mathcal{P}^2(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \mathcal{P}\mu_A`
    \mu_{\mathcal{P}(A)}`
    \mu_A`
    \mu_A]
  \efig
  & \quad &
  \bfig
  \qtriangle|amm|/->`=`->/[
    \mathcal{P}(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \eta_{\mathcal{P}(A)}``
    \mu_A]
  \btriangle|mma|/->`=`->/[
    \mathcal{P}(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \mathcal{P}\eta_A``
    \mu_A]
  \efig
\end{array}
\]
Using diagram chasing\footnote{Chasing an element in $\mathcal{P}(A)$
  across the top path, and then across the bottom path should echo
  back what we started with.} it is easy to see that the diagrams on
the right commute.  The left most diagram commutes by the following
equational reasoning:
\[
\begin{array}{lll}
  \mu_{A}(\mathcal{P}(\mu_A)(S \in \mathcal{P}^3(A)))
  & = & \mu_{A}(\{\mu_A(S') \mid S' \in S\})\\
  & = & \bigcup_{S'' \in (\{\mu_A(S') \mid S' \in S\})} S''\\
  & = & \bigcup_{S''' \in \bigcup_{S'' \in S} S''}S'''\\
  & = & \bigcup_{S''' \in \mu_{\mathcal{P}(A)}(S)}S'''\\
  & = & \mu_{A}(\mu_{\mathcal{P}(A)}(S))\\
\end{array}
\]
Note that in addition to the previous diagrams we would also need to
show that $\eta$ and $\mu$ are natural transformations, but we leave
this to the reader. Functions with a type of the form $A \mto
\mathcal{P}(B)$ have a special place in computer science, because they
model non-determinism.
% section what_is_a_monad_really (end)

\section{Jumping inside a monad}
\label{sec:jumping_inside_a_monad}

Suppose $(T : \cat{C} \mto \cat{C},\eta,\mu)$ is a monad.  Then we can
think of $\cat{C}$ as the pure world, and the world inside $T$ as the
impure world, or the universe of computations.  Given such a monad can
we define exactly what this impure world is?  It turns out we can by
constructing the underlying category of the monad.  There happens to
be two such categories, but they are related.

\subsection{The Kleisli category}
\label{subsec:the_kleisli_category}
Suppose we have a monad $(T,\eta,\mu)$ on some category $\cat{C}$.
The \textbf{Kleisli category} of the monad $T$ is denoted $\cat{C}_T$.
The objects of $\cat{C}_T$ are the objects of $\cat{C}$, and the
morphisms of $\cat{C}_T$ from an object $A$ to an object $B$ are the
morphisms of $\cat{C}$ from $A$ to $TB$.  That is, $\cat{C}_T(A,B) =
\cat{C}(A,TB)$.  We will denote the morphisms in $\cat{C}_T$ as
$\hat{f}$.

Before we can do anything we must first show that $\cat{C}_T$ is
indeed a category.
\begin{lemma}
  \label{lemma:Kleisli_is_a_category}
  Suppose $(T,\eta,\mu)$ is a monad on $\cat{C}$.  Then the Kleisli
  construction $\cat{C}_T$ is a category.
\end{lemma}
\begin{proof}
  Suppose $f : A \mto TB$ is a morphism.  Then the \textbf{Kleisli
    lifting} of $f$ is the morphism $\overline{f}$:
  \[ 
  \bfig
  \qtriangle[
    TA`
    T^2B`
    TB;
    Tf`
    \overline{f}`
    \mu_B]
  \efig
  \]
  \noindent
  \textbf{Composition.} Suppose $\hat{f} : A \mto B$ and $\hat{g} : B
  \mto C$ are two morphisms in $\cat{C}_T$.  These are equivalent to
  the morphisms $f : A \mto TB$ and $g : B \mto TC$ in $\cat{C}$.
  Then their composition, $\hat{f};\hat{g} : A \mto C$ in $\cat{C}_T$
  is defined by $f;\overline{g}$ in $\cat{C}$.  Thus, composition in
  $\cat{C}_T$ is composition in $\cat{C}$ where the second morphism is
  lifted.

  We have to prove that this composition is associative.  Suppose
  $\hat{f} : A \mto B$, $\hat{g} : B \mto C$, and $\hat{h} : C \mto D$
  are morphisms of $\cat{C}_T$.  These are all equivalent to $f : A
  \mto TB$, $g : B \mto TC$, and $h : C \mto TD$ from $\cat{C}$.

  \ \\
  \noindent
  It suffices to show that:
  \[
  (f;\overline{g});\overline{h} = f;\overline{(g;\overline{h})}
  \]  
  We can prove this by showing that the following diagram commutes:
  \[
  \bfig
  \square|amma|/->`->``->/<800,1000>[
    A`
    TB`
    TB`
    T^2C;
    f`
    f``
    Tg]
  \square(800,0)|amma|/->``->`->/<800,1000>[
    TB`
    T^2C`
    T^2C`
    T^3D;
    Tg``
    T^2h`
    T^2h]
  \square(1600,0)|amma|/->`->``->/<800,1000>[
    T^2C`
    TC`
    T^3D`
    T^2D;
    \mu_C`
    T^2h``
    T\mu_D]
  \square(2400,0)|amma|/->``->`->/<800,1000>[
    TC`
    T^2D`
    T^2D`
    TD;
    Th``
    \mu_D`
    \mu_D]
  \Atriangle(1600,0)/<-`->`/<800,500>[
    T^2D`
    T^3D`
    TD;
    \mu_{TD}`
    \mu_D`]
  \morphism(2400,1000)|m|<0,-500>[
    TC`
    T^2D;
    Th]
  \efig
  \]
  The left square trivially commutes, the left-most upper-right square
  commutes by naturality of $\mu$, the right-most upper-right square
  trivially commutes, and the right-lower triangle commutes by the
  monad laws.

  \ \\
  \noindent
  \textbf{Identities.} Suppose $A$ is an object of $\cat{C}_T$.  Then
  we need to show there there exists a morphism $\hat{\id}_A : A \mto
  A$ such that for any morphism $\hat{f} : A \mto B$ we have
  $\hat{\id}_A;\hat{f} = \hat{f} = \hat{f};\hat{\id_B}$.  The only
  option we have is $\eta_A : A \mto TA$, because it is the only
  morphism from $\cat{C}$ with the required form that we know always
  exists.  Thus, $\hat{\id}_A = \eta_A$.  The following commutative
  diagrams imply our desired property:
  \[
  \begin{array}{lll}
    \bfig
    \Vtrianglepair/->`->`->``->/<500,500>[
      A`
      TB`
      T^2B`
      TB;
      f`
      \eta_{TA}`
      f``
      \mu_B]
    \Atriangle(0,500)/<-`->`/<500,500>[
      TA`
      A`
      T^2B;
      \eta_A`
      Tf`]
    \morphism(500,500)/=/<0,-500>[
      TB`
      TB;]
    \efig
    & \quad &
    \bfig
    \Vtrianglepair/->`->`->``->/<500,500>[
      A`
      TB`
      T^2B`
      TB;
      f`
      T\eta_B`
      f``
      \mu_B]
    \morphism(500,500)/=/<0,-500>[
      TB`
      TB;]
    \efig
  \end{array}
  \]  
  The left diagram commutes, because the upper triangle commutes by
  naturality of $\eta$, and the lower-left triangle commutes by the
  monad laws. The right diagram commutes, because the right-most
  diagram commutes by the monad laws.
\end{proof}

Notice that the previous proof explicitly defines the notion of
Kleisli lifting of a morphism.  The astute reader will notice that we
have seen this before.  Consider monads from a functional programming
perspective, we can see that \verb!return : A -> m A! corresponds to
$\eta_A : A \mto TA$, but what does bind,
\verb!>>= :: m b -> (b -> m c) -> m c!, correspond to?  Surely it is
not $\mu_A : T^2A \mto TA$.  Consider the following equivalent form of
bind obtained by currying:
\[
\verb!>>= :: (b -> m c) -> (m b -> m c)!
\]
This looks a lot like the Kleisli lifting:
\[
\mathsf{Hom}_{\cat{C}}(B,TC) \mto \mathsf{Hom}_{\cat{C}}(TB,TC)
\]
In fact, it is!  One of the most important realizations that Moggi had
was that programming in a monad amounts to programming in the Kleisli
category of the monad.  As we can see \verb!bind! and $\mu$ are not
completely unrelated, and one can actually define each of them in
terms of the other.  So monads could be defined in terms of bind and
then we could derive $\mu$, but we leave the details to the reader.
% subsection the_kleisli_category (end)

\subsection{The Eilenberg-Moore category}
\label{subsec:the_eilenberg-moore_category}
A second more general category that corresponds to the universe inside
of a monad is called the Eilenberg-Moore category.  Suppose $(T,
\eta,\delta)$ is a monad on the category $\cat{C}$.  Then a
\textbf{$T$-algebra} is a pair $(A,h_A)$ of an object $A$ of $\cat{C}$
and a morphism, called the structure map, $h_A : TA \mto A$ such that
the following diagrams commute:
\[
\begin{array}{lll}
  \bfig
\square|amma|<700,500>[
  T^2A`
  TA`
  TA`
  A;
  Th_A`
  \mu_A`
  h_A`
  h_A]
\efig
& \quad &
\bfig
\qtriangle|amm|/->`=`->/[
  A`
  TA`
  A;
  \eta_A``
  h_A]
\efig
\end{array}
\]
A morphism $f : (A,h_A) \mto (B,h_B)$ between $T$-algebras is a
morphism $f : A \mto B$ of $\cat{C}$ such that the following diagram
commutes:
\[
\bfig
\square|amma|<700,500>[
  TA`
  TB`
  A`
  B;
  Tf`
  h_A`
  h_B`
  f]
\efig
\]
The \textbf{Eilenberg-Moore category} $\cat{C}^T$ of a monad
$(T,\eta,\mu)$ has as objects all the $T$-algebras and as morphisms
all of the $T$-algebras morphisms.  The categorical structure of
$\cat{C}^T$ is inherited from the underlying category $\cat{C}$ as the
following result shows.
\begin{lemma}
  \label{lemma:EMC-is-cat}
  Suppose $(T,\eta,\mu)$ is a monad on a category $\cat{C}$.  Then
  $\cat{C}^T$ is a category.
\end{lemma}
\begin{proof}
  Suppose $(T,\eta,\mu)$ is a monad on a category $\cat{C}$.

  \ \\
  \noindent
  \textbf{Composition.}  Suppose $f : (A,h_A) \mto (B,h_B)$ and $g :
  (B,h_B) \mto (C,h_C)$ are two $T$-algebra morphisms.  The
  composition $f;g : A \mto C$ is a $T$-algebra morphism between
  $T$-algebras $(A,h_A)$ and $(C,h_C)$ because the following diagram
  commutes:
  \[
  \bfig
  \square|amma|<700,500>[
    TA`
    TB`
    A`
    B;
    Tf`
    h_A`
    h_B`
    f]
    \square(700,0)|amma|<700,500>[
    TB`
    TC`
    B`
    C;
    Tg`
    h_B`
    h_C`
    g]
  \efig
  \]
  Each square commutes by the respective diagram for each morphism.
  Associativity holds trivially, because it holds in $\cat{C}$.

  \ \\
  \noindent
  \textbf{Identities.} Given a $T$-algebra, $(A,h_A)$, we must define
  an identity morphism $\id : (A,h_A) \mto (A,h_A)$, but we can simply
  take $\id_A : A \mto A$ as this morphism, because the following
  diagram commutes:
  \[
  \bfig
  \square<700,500>[
    TA`
    TA`
    A`
    A;
    T\id_A`
    h_A`
    h_A`
    \id_A]
  \efig
  \]
  This diagram commutes, because we know $T\id_A = \id_{TA}$, because
  $T$ is an endofunctor on $\cat{C}$.  Composition will respect
  identities, because composition in $\cat{C}$ does.
\end{proof}

The Eilenberg-Moore category is related to the Kleisli category in the
following way.  Define the category $\mathsf{Free}(\cat{C}^T)$ to be
the full subcategory of $\cat{C}^T$ with objects the free $T$-algebras
of the form $(TA,\mu_A)$ the diagram making this a $T$-algebra is the
monad law for $\mu$. Morphisms in $\mathsf{Free}(\cat{C}^T)$ are all
the $T$-algebras morphisms between free $T$-algebras.
\begin{lemma}
  \label{lemma:the_kleisli_category_is_a_full_subcategory_of_the_eilenberg-moore_category}
  Suppose $(T,\eta,\mu)$ is a monad on the category $\cat{C}$.  Then
  the category $\cat{C}_T$ is a full subcategory of $\cat{C}^T$.
\end{lemma}
\begin{proof}
  The full proof of this is out of scope of this short lecture note,
  but it is possible to show that $\cat{C}_T$ is equivalent to
  $\mathsf{Free}(\cat{C}^T)$, and hence, we obtain our result.
\end{proof}

The benefit of the Eilenberg-Moore category is that it is often easier
to prove properties about it than the Kleisli category.  Since the
Kleisli category is a full subcategory of the Eilenberg-Moore category
any property that holds on the Eilenberg-Moore category also holds for
the Kleisli category.

Using the Eilenberg-Moore category it is possible to decompose a monad
into an adjunction.  Suppose $(T, \eta,\mu)$ is a monad on the
category $C$.  Then notice that there is a functor $F_T : \cat{C} \mto
\cat{C}^T$ which takes an object $A$ of $\cat{C}$ to the $T$-algebra
$(TA,\mu_A)$, and a morphism $f : A \mto B$ of $\cat{C}$ to the
morphism $Tf : (TA, \mu_A) \mto (TB,\mu_B)$; the monad laws imply
$\mu$ is a structure map for objects of the form $T(-)$, and
naturality of $\mu$ implies that $Tf$ is a $T$-algebra morphism. It is
easy to see that $F_T$ is a functor, because $T$ is. This is known as
the \textbf{free functor} of the monad $T$.  There also happens to be
a functor $U_T : \cat{C}^T \mto \cat{C}$ which takes objects $(A,h_A)$
of $\cat{C}^T$ to an object $A$ of $\cat{C}$, and morphisms $f :
(A,h_A) \mto (B,h_B)$ to $f : A \mto B$.  Clearly, $U_T$ is a functor.
It is known as the \textbf{forgetful functor}.

We can now define a natural transformation $\varepsilon^T : FU \mto
\mathsf{Id}$, where $\mathsf{Id} : \cat{C} \mto \cat{C}$ is the
identity functor.  The functor $FU : \cat{C}^T \mto \cat{C}^T$
transforms objects $(A,h_A)$ into $FU(A,h_A) = FA =
(TA,\mu_A)$. Hence, the components of $\varepsilon^T$ must be defined
by $\varepsilon^T_{(A,h_A)} = h_A : (TA, \mu_A) \mto (A, h_A)$; the
conditions on the structure map insure this is indeed a $T$-algebra
morphism.  Naturality holds because $\varepsilon^T_{(A,h_A)}$ is the
structure map of $A$.  We also have a natural transformation $\eta^T :
\mathsf{Id} \mto UF$.  The functor $UF : \cat{C} \mto \cat{C}$ is
defined by $UFA = U(TA,\mu_A) = TA$.  Thus, the components of $\eta^T$
are defined by $\eta^T_A = \eta_A : A \mto TA$.  Clearly, $\eta^T$ is
natural, because $\eta_A$ is.

These two natural transformations are related by the following diagrams:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \bfig
      \qtriangle|amm|/->`=`->/<700,500>[
        FA`
        FUFA`
        FA;
        F\eta^T_A``
        \varepsilon^T_{FA}]
      \efig
      & \quad &
      \bfig
      \qtriangle|amm|/->`=`->/<950,500>[
        U(A,h_A)`
        UFU(A,h_A)`
        U(A,h_A);
        \eta^T_{U(A,h_A)}``
        U\varepsilon^T_{(A,h_A)}]
      \efig
    \end{array}
  \end{math}
\end{center}
In the left diagram $F\eta^T_A = T\eta_A$ and $\varepsilon^T_{FA} =
\mu_A$, and thus, that diagram is equivalent to one of the monad laws
(Definition~\ref{def:monad}).  In the right diagram $\eta^T_{U(A,h_A)}
= \eta_A$ and $U\varepsilon^T_{(A,h_A)} = h_A$, and thus, this diagram
becomes one of the conditions of the structural map.

This structure implies that we have an adjunction:
\begin{center}
  \begin{math}
    \bfig
    %% \Loop(0,0)\cat{C}(ur,ul)_T
    \morphism(0,0)|a|/{@{>}@/^1.5em/}/<900,0>[\cat{C}`\cat{C}^T;F]
    \morphism(0,0)|b|/{@{<-}@/_1.5em/}/<900,0>[\cat{C}`\cat{C}^T;U]
    \place(450,0)[\perp]
    \efig
  \end{math}
\end{center}
The symbol $\perp$ indicates that the left adjoint is $F$ and the
right $G$ which is usually denoted $F \dashv G$.  Finally, it is easy
to see that $T = UF : \cat{C} \mto \cat{C}$.  A similar construction
can be done using the Kleisli category.
% subsection the_eilenberg-moore_category (end)

% section jumping_inside_a_monad (end)

\section{Categorical Model of $\lambda_T$}
\label{sec:categorical_model_of_lambdaT}

At this point we have introduced the basics of monads categorically.
In this section we show how to categorically model a simple type
theory with monads called $\lambda_T$.  We can view $\lambda_T$ as the
smallest typed functional programming language with monads, but by
extending this language with more features one can study monads
incrementally.

The syntax for $\lambda_T$ is as follows:
\[
\small
\begin{array}{lll}
  \text{(types)}  & [[A]],[[B]],[[C]] := [[1]] \mid [[T A]] \mid [[A x B]] \mid [[A -> B]]\\
  \text{(terms)} & [[t]] := [[x]] \mid [[triv]] \mid [[(t1,t2)]] \mid [[fst t]] \mid [[snd t]] \mid [[\x:A.t]] \mid [[t1 t2]] \mid [[return t]] \mid [[let x <- t1 in t2]]\\
  \text{(contexts)} & [[G]] := [[.]] \mid [[x : A]] \mid [[G1,G2]]
\end{array}
\]
We can see that this is an extension of the simply typed
$\lambda$-calculus.  We add a new type $[[T A]]$ which represents an
arbitrary monad, and new terms for return and bind denoted $[[return
    t]]$ an $[[let x <- t1 in t2]]$ respectively.  This language is
very similar to Moggi's metalanguage \cite{Moggi:1988}.

The typing rules for $\lambda_T$ can be found in
Figure~\ref{fig:lambdaT-typing}, and the reduction rules are in
Figure~\ref{fig:lambdaT-eval}.
\begin{figure}
  \begin{mathpar}
    \Ottdrulevar{} \and
    \Ottdruletriv{} \and
    \Ottdrulepair{} \and
    \Ottdrulefirst{} \and
    \Ottdrulesecond{} \and
    \Ottdrulelambda{} \and
    \Ottdruleapp{} \and
    \Ottdrulereturn{} \and
    \Ottdrulebind{}
  \end{mathpar}
  \caption{Typing Rules for $\lambda_T$}
  \label{fig:lambdaT-typing}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \OttdrulerXXbeta{} \and
    \OttdrulerXXfirst{} \and
    \OttdrulerXXsecond{} \and
    \OttdrulerXXbind{}
  \end{mathpar}
  \caption{Reduction Rules for $\lambda_T$}
  \label{fig:lambdaT-eval}
\end{figure}
The reduction rules are rather simplistic, but are advanced enough for
the purpose of this note.  Congruence rules are omitted in the
interest of brevity.  There are also more monadic rules that one might
one, for example a commuting conversion of bind, but we leave these
out.

The main question of this section is, what is the categorical model of
$\lambda_T$?  We know we can interpret $\lambda_T$ excluding the
monadic bits into a cartesian closed category.  Thus, the model of
full $\lambda_T$ must be some extension of a cartesian closed category
with a monad.  Is it enough to simply take a cartesian closed category
$\cat{C}$ with a monad $(T,\eta,\mu)$ on $\cat{C}$?

Suppose $(\cat{C}, 1, \times, \to)$ is a cartesian closed category,
and $(T,\eta,\mu)$ is a monad on $\cat{C}$.  Types are interpreted
into this model as follows:
\[
\begin{array}{lll}
  [[ [1] ]] & = & 1\\
  [[ [A x B] ]] & = & [[ [A] x [B] ]]\\
  [[ [A -> B] ]] & = & [[ [A] -> [B] ]]\\
  [[ [T A] ]] & = & [[ T [A] ]]
\end{array}
\]
Contexts $\Gamma = [[x1 : A1]],\ldots,[[xi : Ai]]$ will be interpreted
into $\cat{C}$ by $[[ [G] ]] = [[ [A1] ]] \times \cdots \times [[ [ Ai
] ]]$.  To make the syntax less cluttered we will drop the
interpretation brackets from the interpretation of types.

We will interpret each typing judgment $[[G |- t : A]]$ as a morphism
$[[ [G] ]] \mto^{[[ [t] ]]} [[ [A] ]]$ by induction on the form of the
typing judgment. Now consider the two monadic typing rules:
\[
\begin{array}{lll}
  \Ottdrulereturn{} & \quad & \Ottdrulebind{}
\end{array}
\]
Consider the left rule, and suppose we have a morphism $t : [[G]] \mto
[[A]]$ in $\cat{C}$.  Then we must construct a morphism of the form
$[[G]] \mto [[T A]]$, but this is easily done by $t;\eta_A : [[G]]
\mto [[T A]]$.  Thus, the interpretation of $[[ [return t] ]]$ is
$[[ [t] ]];\eta_A$.

Now consider the rule $T_e$, and suppose we have morphisms $[[t1]] :
[[G]] \mto [[T A]]$ and $[[t2]] : [[G]] \times [[A]] \mto [[T B]]$.
We are expecting to Kleisli lift $[[t2]]$ to $\overline{t_2} = [[(T
    t2)]];\mu_B : T ([[G]] \times [[A]]) \mto T [[B]]$, and then
compose $\langle \id_{[[G]]} , [[t1]] \rangle : [[G]] \mto [[G]]
\times [[T A]]$ with $\overline{t_2}$, but the types do not match!  If
we had a natural transformation $\mathsf{st}_{A,B} : A \times T B \mto
T(A \times B)$ then we could finish the job by interpreting
$[[G |- let x <- t1 in t2 : T B]]$ by
$\langle \id_{[[G]]} , [[t1]] \rangle;\mathsf{st}_{[[G]],[[A]]};\overline{t_2} : [[G]] \mto [[T B]]$.
Therefore, an arbitrary monad does not have enough structure to model
the bind rule in the presence of multiple hypotheses.  Instead we need
a strong monad.

\begin{definition}
  \label{def:strong-monad}
  A monad $(T,\eta,\mu)$ on a category $\cat{C}$ with all finite
  products is \textbf{strong} if there exists a natural transformation
  $\mathsf{st}_{A,B} : A \times T B \mto T(A \times B)$ called the
  \textbf{tensorial strength} of the monad.  In addition, the following
  diagrams must commute:
  \begin{center}
    \begin{math}
      \begin{array}{ccc}
        \bfig
    \qtriangle|amm|<700,500>[
      1 \times TA`
      T(1 \times A)`
      TA;
      \mathsf{st}_{1,A}`
      \rho_{TA}`
      T\rho_A]
    \efig
    & \quad & 
    \bfig
    \btriangle|maa|/<-``->/<800,500>[
      A \times TB`
      A \times T^2 B`
      T(A \times TB);
      \id_A \times \mu_B``
      \mathsf{st}_{A,TB}]

    \dtriangle(800,0)|ama|/`<-`->/<800,500>[
      T(A \times B)`
      T(A \times TB)`
      T^2(A \times B);`
      \mu_{A \times B}`
      T\mathsf{st}_{A,B}]
  
    \Atriangle(0,500)|mma|<800,300>[
      A \times B`
      A \times TB`
      T(A \times B);
      \id_A \times \eta_B`
      \eta_{A \times B}`
      \mathsf{st}_{A,B}]
    \efig
      \end{array}
    \end{math}
  \end{center}
  \begin{mathpar}       
    \bfig
    \square|amma|/`->``->/<1000,500>[
      (A \times B) \times C``
      A \times (B \times C)`
      A \times T(B \times C);`
      \alpha_{A,B,C}``
      \id_A \times \mathsf{st}_{B,C}]
    \morphism(1000,0)<1200,0>[
      A \times T(B \times C)`
      T(A \times T(B \times C));
      \mathsf{st}_{A,B \times C}]
    \morphism(0,500)<2200,0>[
      (A \times B) \times C`
      T((A \times B) \times C);
      \mathsf{st}_{A \times B,C}]
    \morphism(2200,500)|m|<0,-500>[
      T((A \times B) \times C)`
      T(A \times T(B \times C));
      T\alpha_{A,B,C}]
    \efig
  \end{mathpar}
\end{definition}
Adopting strong monads instead of arbitrary ones yields a sound and
complete model.
\begin{definition}
  \label{def:lambdaT-model}
  A \textbf{$\lambda_T$ model} consists of a cartesian closed category
  $\cat{C}$ equipped with a strong monad $(T,\eta,\mu)$ on $\cat{C}$.
\end{definition}
\noindent
Finally, we have the following:
\begin{theorem}[Soundness]
  \label{thm:soundness}
  Suppose $(T : \cat{C} \mto \cat{C},\eta,\mu)$ is a $\lambda_T$ model.  Then if $[[G |- t1 :
      A]]$ and $[[t1 ~> t2]]$, the $[[ [t1] ]] \cong [[ [t2] ]] : [[ [G] ]] \mto [[ [A] ]]$ in $\cat{C}$.
\end{theorem}
% section categorical_model_of_lambdaT (end)


\section{Monads are modular, right?}
\label{sec:monads_are_modular,_right?}

The most important concept of category theory, logic, and functional
programming is composition.  In practice, it is very common to need
several different types of side effects.  Naturally, some programs
will use different ones, and others may use all of them.  So given
monads $(T_1,\eta_1,\mu_1)$ and $(T_2,\eta_2,\mu_2)$ on a category
$\cat{C}$ can we compose these together and obtain a monad
$(T_3,\eta_3,\mu_3)$ that encompasses the side effects of both $T_1$
and $T_2$?

One might think that the question is obviously true.  This is category
theory, right?  Functors compose, and so we should be able to compose
monads, but in what order?  It turns out that we cannot even define
join of this composition.  If we take $T_1;T_2 : \cat{C} \mto \cat{C}$
to be the composition, then notice that we can easily obtain a natural
transformation $\eta_3 = A \mto^{\eta_2} T_2 A \mto^{\eta_1} T_1(T_2
A)$, but notice that we cannot define $\mu_3 : T_1(T_2(T_1(T_2 A)))
\mto T_1(T_2 A)$ in terms of $\mu_1 : T^2_1 \mto T_1$ and $\mu_2 :
T^2_2 \mto T_2$.  So this will not work.  

Composition of monads has been a hot topic since their conception.  In
fact, Moggi spent a lot of time thinking about this; see
\cite{Moggi:1989a}. Papers on this concept pop up pretty consistently
each year since monads where introduced to the functional programming
community.  However, most of these papers exclude a categorical model.
This is rather upsetting, because the model allows us to decide on the
approaches merits.  Monads are a categorical concept after all, and
when we extend their use we should provide an elegant categorical
model.

In this section we will cover some of the most popular ways of
composing monads. We focus on the categorical models, but we will give
brief descriptions of how these can be added to a functional
programming language.

\subsection{Distributive Laws}
\label{subsec:distributive_laws}
Recall that we were unable to define $\mu_3 : T_1(T_2(T_1(T_2 A)))
\mto T_1(T_2 A)$ in terms of $\mu_1 : T^2_1 \mto T_1$ and $\mu_2 :
T^2_2 \mto T_2$.  But, if we could first commute $T_2T_1$ in the
source of $\mu_3$, then we could.  This is exactly what distributive
laws give us.

Given two monads $(T_1,\eta_1,\mu_1)$ and $(T_2,\eta_2,\mu_2)$ on a
category $\cat{C}$, a \textbf{distributive law} of $T_2$ over $T_1$ is
a natural transformation $\mathsf{dist} : T_1T_2 \mto T_2T_1$
subject to the following commutative diagrams:
\begin{center}  
  \begin{math}
    \begin{array}{lll}
      \bfig
      \qtriangle|amm|<500,800>[
        T_1`
        T_1T_2`
        T_2T_1;
        T_1\eta_2`
        \eta_2T_1`
        \mathsf{dist}]
      \square(500,0)|amma|/<-`->``<-/<700,800>[
        T_1T_2`
        T_1T_2T_2`
        T_2T_1`
        T_2T_2T_1;
        T_1\mu_2`
        \mathsf{dist}``
        \mu_2T_1]
      \morphism(1200,800)|m|<0,-400>[
        T_1T_2T_2`
        T_2T_1T_2;
        \mathsf{dist}T_2]
      \morphism(1200,400)|m|<0,-400>[
        T_2T_1T_2`
        T_2T_2T_1;
        T_2\mathsf{dist}]
      \efig
      & \quad &
      \bfig
      \qtriangle|amm|<500,800>[
        T_2`
        T_1T_2`
        T_2T_1;
        \eta_1T_2`
        T_2\eta_1`
        \mathsf{dist}]
      \square(500,0)|amma|/<-`->``<-/<700,800>[
        T_1T_2`
        T_1T_1T_2`
        T_2T_1`
        T_2T_1T_1;
        \mu_1T_2`
        \mathsf{dist}``
        T_2\mu_1]
      \morphism(1200,800)|m|<0,-400>[
        T_1T_1T_2`
        T_1T_2T_1;
        T_1\mathsf{dist}]
      \morphism(1200,400)|m|<0,-400>[
        T_1T_2T_1`
        T_2T_1T_1;
        \mathsf{dist}T_1]
      \efig
    \end{array}
  \end{math}
\end{center}
Distributive laws are due to Beck \cite{Beck:1969}, and were
extensively studented by Manes and Mulry \cite{Manes:2007,Manes:2008}.
Please see the latter for further references on the subject.

We now have the following result:
\begin{theorem}
  \label{thm:compose_1}
  Suppose $(T_1,\eta_1,\mu_1)$ and $(T_2,\eta_2,\mu_2)$ are two monads
  on $\cat{C}$, and $\mathsf{dist} : T_1T_2 \mto T_2T_1$ is a
  distributive law.  Then the endofunctor $T_2T_1$ is a monad on
  $\cat{C}$.
\end{theorem}
\begin{proof}
  It suffices to define $\eta_3 : A \mto T_2T_1A$ and $\mu_3 :
  T_2T_1T_2T_1 A \mto T_2T_1 A$, and show they satisfy the monad laws
  (Definition~\ref{def:monad}).

  \ \\ \noindent  
  We have the following definitions:
  \[
  \begin{array}{lll}
    \eta_3 = A \mto^{\eta_2} T_2A \mto^{T_2\eta_1} T_2T_1A\\
     \mu_3 = T_2T_1T_2T_1A \mto^{T_2\mathsf{dist}_{T_1A}} T^2_2T^2_1 A \mto^{T^2_2\mu_1} T^2_2T_1A \mto^{\mu_2} T_2T_1A
  \end{array}
  \]
  Now we show that these definitions satisfy the monad laws:
  \begin{itemize}
  \item[] Case.
    \[
    \bfig
    \Square|amma|[
      (T_2T_1)^3 A`
      (T_2T_1)^2A`
      (T_2T_1)^2A`
      T_2T_1A;
      T_2T_1\mu_3`
      \mu_3T_2T_1`
      \mu_3`
      \mu_3]
    \efig
    \]
    This case follows from the fact that the following diagram
    commutes:
    \begin{center}
      \begin{math}
        \bfig
        \square|amma|<1100,500>[
          T_2T_1T_2T_1T_2T_1A`
          T_2T_1T^2_2T^2_1A`
          T^2_2T^2_1T_2T_1A`
          T^2_2T_1T_2T^2_1A;
          T_2T_1T_2\mathsf{dist}`
          T_2\mathsf{dist}T_1T_2T_1`
          T_2\mathsf{dist}T_2T^2_1`
          T^2_2T_1\mathsf{dist}T_1]

        \square(1100,0)|amma|<1100,500>[
          T_2T_1T^2_2T^2_1A`
          T_2T_1T^2_2T_1A`
          T^2_2T_1T_2T^2_1A`
          T^2_2T_1T_2T_1A;
          T_2T_1T^2_2\mu_1`
          T_2\mathsf{dist}T_2T^2_1`
          T_2\mathsf{dist}T_2T_1`
          T^2_2T_1T_2\mu_1]

        \square(1100,-500)|amma|<1100,500>[
          T^2_2T_1T_2T^2_1A`
          T^2_2T_1T_2T_1A`
          T^3_2T^3_1A`
          T^3_2T^2_1A;
          T^2_2T_1T_2\mu_1`
          T^2_2\mathsf{dist}T^2_1`
          T_2\mathsf{dist}T_1`
          T^3_2T_1\mu_1]

        \square(1100,-1000)|amma|<1100,500>[
          T^3_2T^3_1A`
          T^3_2T^2_1A`
          T^3_2T^2_1A`
          T^3_2T_1A;
          T^3_2T_1\mu_1`
          T^3_2\mu_1T_1`
          T^3_2\mu_1`
          T^3_2\mu_1]

        \square(1100,-1500)|amma|<1100,500>[
          T^3_2T^2_1A`
          T^3_2T_1A`
          T^2_2T^2_1A`
          T^2_2T_1A;
          T^3_2\mu_1`
          \mu_2T_2T^2_1`
          \mu_2T_2T_1`
          T^2_2\mu_1]

        \square(0,-1500)|amma|<1100,500>[
          T^2_2T_1T_2T_1A`
          T^3_2T^2_1A`
          T_2T_1T_2T_1A`
          T^2_2T^2_1A;
          T^2_2\mathsf{dist}T_1`
          \mu_2T_1T_2T_1`
          \mu_2T_2T^2_1`
          T_2\mathsf{dist}T_1]

        \morphism(0,0)|m|<0,-1000>[
          T^2_2T^2_1T_2T_1A`
          T^2_2T_1T_2T_1A;
          T^2_2\mu_1T_2T_1]

        \square(2200,-1000)|amma|<1100,500>[
          T^3_2T^2_1A`
          T^2_2T^2_1A`
          T^3_2T_1A`
          T^2_2T_1A;
          T_2\mu_2T^2_1`
          T^3_2\mu_1`
          T^2_2\mu_1`
          T_2\mu_2T_1]

        \square(2200,-1500)|amma|<1100,500>[
          T^3_2T_1A`
          T^2_2T_1A`
          T^2_2T_1A`
          T_2T_1A;
          T_2\mu_2T_1`
          \mu_2T_2T_1`
          \mu_2T_1`
          \mu_2T_1]

        \qtriangle(2200,-500)|amm|/->``->/<1100,1000>[
          T_2T_1T^2_2T_1A`
          T_2T_1T_2T_1A`
          T^2_2T^2_1A;
          T_2T_1\mu_2``
          T_2\mathsf{dist}T_1]

        \place(550,250)[(1)]
        \place(1650,250)[(2)]
        \place(2750,0)[(3)]
        \place(550,-500)[(4)]
        \place(1650,-250)[(5)]
        \place(1650,-750)[(6)]
        \place(2750,-750)[(7)]
        \place(550,-1250)[(8)]
        \place(1650,-1250)[(9)]
        \place(2750,-1250)[(10)]
        \efig
      \end{math}
    \end{center}
    Diagrams one, two, and five commute by naturality of
    $\mathsf{dist}$, diagrams seven, eight, and nine commute by
    naturality of $\mu_2$, diagrams six and ten commute by the monad
    laws, and diagrams three and four commute by the distributive
    laws.

  \item[] Case.
    \[
    \bfig
    \qtriangle|amm|/->`=`->/<800,500>[
      T_2T_1A`
      (T_2T_1)^2A`
      T_2T_1A;
      \eta_3``
      \mu_3]
    \efig
    \]
    This diagram commutes because the following one does:
    \begin{center}
      \begin{math}
        \bfig
        \qtriangle|amm|/->`->`->/<1000,500>[
            T^2_2T_1A`
            T_2T_1T_2T_1A`
            T^2_2T^2_1A;
            T_2\eta_1T_2T_1`
            T^2_2\eta_1T_1`
            T_2\mathsf{dist}T_1]

        \dtriangle(0,-500)|mma|/`->`=/<1000,500>[
          T^2_2T^2_1A`
          T^2_2T_1A`
          T^2_2T_1A;`
          T^2_2\mu_1`]

        \square(-1000,-500)|amma|/->`=`=`<-/<1000,1000>[
          T_2T_1A`
          T^2_2T_1A`
          T_2T_1A`
          T^2_2T_1A;
          \eta_2T_2T_1```
          \mu_2T_1]
        \efig
      \end{math}
    \end{center}

    The left and the right lower squares commute by the monad laws,
    and the right triangle commutes by the distributive laws.

  \item[] Case.
    \[
    \bfig
    \btriangle|mma|/->`=`->/<800,500>[
      T_2T_1A`
      (T_2T_1)^2A`
      T_2T_1A;
      T_2T_1\eta_3``
      \mu_3]
    \efig
    \]

    This is case is similar to the previous one.

  \end{itemize}

\end{proof}

Many concrete monads have the benefit that we can define the
distributive laws, and hence, can be composed.  As an example suppose
we wanted to compose the maybe monad and the list monad.  In Haskell,
we can define the following distributive law\footnote{For the entire
  implementation please see
  \url{https://github.com/heades/intro-monads/blob/master/MaybeList.hs}.}
(writing \verb!List a!  instead of \verb![a]! for readability):
\begin{center}
  \begin{verbatim}
    dist :: List (Maybe a) -> Maybe (List a)
    dist [] = Just []
    dist (Nothing:xs) = Nothing
    dist (Just x:xs) = dist xs >>= (\l -> return (x:l)) 
  \end{verbatim}
\end{center}
This definition shows that applying \verb!dist! to a list where every
element is of the form \verb!Just x! for some \verb!x! of type
\verb!a! results in \verb!Just l! where \verb!l! contains all of the
elements like \verb!x!.  If \verb!Nothing! ever appears then
\verb!dist! returns \verb!Nothing!.  This fits well with how the maybe
monad operates.

Using \verb!dist! we can define the monad \verb!Maybe (List a)!:
\begin{center}
  \small
  \begin{verbatim}
    returnML :: a -> Maybe (List a)
    joinML :: Maybe (List (Maybe (List a))) -> Maybe (List a)
    bindML :: Maybe (List a) -> (a -> Maybe (List a)) -> Maybe (List a)
  \end{verbatim}
\end{center}
There are many more example use cases.  See the work of Jones and
Duponcheel \cite{Jones:1993} for some variations of this type of
composition in Haskell.

One of the negatives of distributive laws is that a distributive law
may not be definable for a particular pair of monads.  For example, in
Haskell it is not possible to define a distributive law between the
I/O monad and the state monad.  
% subsection distributive_laws (end)

\subsection{Monad Transformers}
\label{subsec:monad_transformers}

Moggi \cite{Moggi:1989a} was perhaps the first to realize that the
success of the monadic approach depends on the need for monadic models
to be modular.  So he spent quite sometime studying a means of
composing monads called \textbf{monad transformers.}

Suppose $\cat{C}$ is a category with products.  Then define the
category $\mathsf{Mon}(\cat{C})$ to have as objects strong monads
(Definition~\ref{def:strong-monad}) and as morphisms strong-monad
morphisms.

\begin{definition}
  \label{def:strong-monad-morphism}
  A \textbf{strong-monad morphism} is a natural transformation,
  $\alpha : T_1 \mto T_2$, where $(T_1,\eta_1,\mu_1,\mathsf{st}_1)$
  and $(T_2,\eta_2,\mu_2,\mathsf{st}_2)$ are strong monads.
  Furthermore, the following diagrams must commute:
  \begin{center}
    \begin{math}
      \begin{array}{cccc}
      \bfig
      \square|amma|/->`=`->`->/<500,500>[
        A`
        T_1A`
        A`
        T_2A;
        \eta_1``
        \alpha_A`
        \eta_2]
      \square(500,0)|amma|/<-`->`->`<-/<500,500>[
        T_1A`
        T^2_1A`
        T_2A`
        T^2_2A;
        \mu_1`
        \alpha_A`
        (\alpha;\alpha)_A`
        \mu_2]
      \efig
      & \quad &
      \bfig
      \square|amma|<1000,500>[
        A \times T_1B`
        T_1(A \times B)`
        A \times T_2B`
        T_2(A \times B);
        \mathsf{st}_1`
        \id_A \times \alpha_B`
        \alpha_{A \times B}`
        \mathsf{st}_2]
      \efig
    \end{array}
    \end{math}
  \end{center}
\end{definition}
\noindent
Now a \textbf{monad transformer} is an endofunctor in $\mathsf{Mon}(\cat{C})$.

Consider the following example due to Moggi \cite{Moggi:1989a}.  Given
a monad $(T, \eta, \mu, \mathsf{st})$ over a category $\cat{C}$ with
products and coproducts, then the monad $T_E$ of
$T$-\textbf{computations with exceptions} is defined as follows:
\begin{itemize}
\item $T_E(A) = T(A + E)$
\item $\eta^E = \mathsf{in}_l;\eta_{A+E}$
\item $\mu^E = \overline{[\mathsf{id}_{T(A+E)},\mathsf{in}_r;\eta_{A+E}]}$
\end{itemize}
In addition, a monad morphism $\alpha : T' \mto T$ induces a monad
morphism $\sigma = \alpha_{A+E} : S_E \mto T_E$.  Finally, for every
monad $(T, \eta, \mu, \mathsf{st})$ there are two monad morphism
$\eta_E : T \mto T_E$ and $\mu_E : {T_E}_E \mto T_E$ making monad
transformers monads in the category $\mathsf{Mon}(\cat{C})$.

As presented here monad transformers are Moggi's monad constructors
\cite{Moggi:1989a}, but in practice they were found to not allow for
many commonly used monads to be composed. Liang et
al. \cite{Liang:1995} extended the approach arriving at a more general
notion of monad transformer that has been adopted in Haskell.
However, this improved the practical side, but without an elegant
categorical model.  In fact, to the knowledge of the author the only
account of a categorical semantics for the monad transformers in
Haskell is detailed in the note by Oleksandr Manzyuk
\cite{Manzyu:2012}, but it is very ad hoc.
% subsection monad_transformers (end)

\subsection{Coproducts}
\label{subsec:coproducts}
Distributive laws nor monad transformers are general solutions to the
composition of monads problem.  Thus, the question is still very much
open. A more recent approach that is more general than both
distributive laws and monads transformers which is based in category
theory was proposed by L\"uth and Ghani \cite{Luth:2002}.  In fact,
distributive laws arrive as special cases of their model.

The main idea is when given two monads $(T_1, \eta_1, \mu_1)$ and
$(T_2, \eta_2, \mu_2)$ one can construct the coproduct monad $(T_1 +
T_2, \eta_+, \mu_+)$ that encompasses the side effects of both monads.
The general construction turns out to be quite complex.  The
interested reader should see their paper \cite{Luth:2002}.
% subsection coproducts (end)
% section monads_are_modular,_right? (end)


\bibliographystyle{plain} \bibliography{references}

\end{document}

