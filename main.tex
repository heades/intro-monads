\documentclass{article}
\usepackage[utf8]{inputenc}

\title{An introduction to that which shall not be named}
\author{Harley Eades III\\Computer Science\\Augusta University\\\href{mailto:heades@augusta.edu}{heades@augusta.edu}}
\date{September 2016}

\usepackage{amsthm, amsmath, amssymb}
\usepackage{mathpartir}
\usepackage{mdframed}           % For the boxes around the systems.
\usepackage[barr]{xy}
\input{type-theory_inc}
%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

\usepackage{proof}
\usepackage{enumerate}
\usepackage{todonotes}
\usepackage{hyperref}

\let\b\relax
\let\d\relax
\let\t\relax

\newcommand{\F}{\mathop{\textbf{F}}}
\renewcommand{\P}{\mathop{\textbf{P}}}
\newcommand{\G}{\mathop{\textbf{G}}}
\renewcommand{\H}{\mathop{\textbf{H}}}

\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\pd}[0]{\times}
\newcommand{\ihom}[0]{\rightarrow}
\newcommand{\st}[2]{\mathsf{st}_{#1,#2}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\b}[1]{\mathsf{b}_{#1}}
\newcommand{\d}[1]{\mathsf{d}_{#1}}
\newcommand{\m}[1]{\mathsf{m}_{#1}}
\newcommand{\n}[1]{\mathsf{n}_{#1}}
\newcommand{\p}[1]{\mathsf{p}_{#1}}
\newcommand{\q}[1]{\mathsf{q}_{#1}}
\newcommand{\t}[0]{\mathsf{t}}
\newcommand{\limp}[0]{\multimap}
\newcommand{\Hom}[3]{\mathsf{Hom}_{#1}(#2,#3)}

\def\cW{\color{white}}

%% Begin Ott
\input{lambdaT-inc}
\renewcommand{\Ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,#4}}
\renewcommand{\OttdrulevarName}[0]{\text{var}}
\renewcommand{\OttdruletrivName}[0]{1_i}
\renewcommand{\OttdrulepairName}[0]{\times_i}
\renewcommand{\OttdrulefirstName}[0]{\times_{e_1}}
\renewcommand{\OttdrulesecondName}[0]{\times_{e_2}}
\renewcommand{\OttdrulelambdaName}[0]{\lambda_i}
\renewcommand{\OttdruleappName}[0]{\lambda_e}
\renewcommand{\OttdrulereturnName}[0]{T_i}
\renewcommand{\OttdrulebindName}[0]{T_e}
%% End Ott
                                   
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{notn}[theorem]{Notation}
\newtheorem{observation}[theorem]{Observation}

\begin{document}

\maketitle

\section{A quick overview from programming}
\label{sec:a_quick_example_from_programming}
Consider a C program with signature \verb!int f(int)!.  Now describe
all possible computations this program can do.  This is a difficult
task, because this function could do a lot, like, prompt the user for
input, send packets across the network, modify global state, and much
more, but then eventually return an integer.

Now consider a purely functional programming language like Haskell
\cite{Haskell} and list all the possible computations the function
\verb!f :: Int -> Int! can do. The list is a lot smaller.  We know
without a doubt that this function must take an integer as an input,
and then do integer computations, and finally return an integer.  No
funny business went on inside this function.  Thus, reasoning about
pure programs is a lot easier.

However, a practical programmer might now be asking, ``How do we get
any real work done in a pure setting?''.  From stage left enters the
monad.  These allow for a programmer to annotate the return types of
functions to indicate which side effects the function will use.  For
example, say we wanted \verb!f! to use a global state of integers,
then its type would be \verb!f :: Int -> State [Int] Int! to indicate
that \verb!f! will take in an integer input, then during computation
will use a global state consisting of a list of integers, but then
eventually return an integer.  Thus, the return type of \verb!f!
  literally lists the side effects the function will use.  Now while
  reasoning about programs we know exactly which side effects to
  consider.

In full generality a monad is a type constructor \verb!m : * -> *!
where \verb!*! is the universe of types.  Given a type \verb!a! we
call the type \verb!m a! the type of computations returning values
of type \verb!a!.  Thus, a function \verb!f : a -> m b! is a function that
takes in values of type \verb!a!, and then returns a computation that
will eventually return a value of type \verb!b!.

Suppose we have \verb!f :: a -> m b! and \verb!g :: b -> m c!, and we
wish to apply \verb!g! to the value returned by \verb!f!. This sounds
perfectly reasonable, but ordinary composition \verb!g.f! does not
suffice, because the return type of \verb!f! is not identical to the
input type of \verb!g!.  Thus, we must come up with a new type of
composition.  To accomplish this in Haskell we first need a new
operator called \textit{bind} which is denoted by
\verb!>>= :: m b -> (b -> m c) -> m c!.  Then composition of \verb!f!
and \verb!g! can be defined by
\verb!\x -> ((f x) >>= g) :: a -> m c!.

So we have a composition for functions whose type has the shape
\verb!a -> m b!, but any self respecting composition has an identity.
This implies that we need some function \verb!id :: a -> m a!, such
that, $\verb!(\x -> (f x) >>= id)! = \verb!f!$ and
$\verb!(\x -> (id x) >>= g)! = \verb!g!$.  This identity is denoted by
\verb!return :: a -> m a! in Haskell, and has to be taken as
additional structure, because it cannot be defined in terms of bind.

Using \verb!bind! and \verb!return! in combination with products, sum
types, and higher-order functions a large number of monads can be
defined, but what are monads really?
% section a_quick_example_from_programming (end)

\section{What is a monad really?}
\label{sec:what_is_a_monad_really}
Monad's first arose in category theory and go back to Eilenberg and
MacLane \cite{MacLane:1971}, but Moggi was the first to propose that
they be used to model effectful computation in a pure setting
\cite{Moggi:1988}.  After learning about Moggi's work Wadler pushed
for their adoption by the functional programming community
\cite{jones1993glasgow,Wadler:1990:CM:91556.91592,Wadler:1992:EFP:143165.143169,Wadler:1995}. This
push resulted in the adoption of monads as the primary means of
effectful programming in Haskell.

In the most general sense a monad is defined as follows:
\begin{definition}
  \label{def:monad}
  Suppose $\cat{C}$ is a category.  Then a \textbf{monad} is a functor
  $T : \cat{C} \mto \cat{C}$ equipped with two natural transformations
  $\eta_A : A \mto T A$ and $\mu_A : T^2 A \mto TA$ such that the
  following diagrams commute:
  \[
  \begin{array}{ccc}
    \bfig
    \Square|amma|[
      T^3 A`
      T^2A`
      T^2A`
      TA;
      T\mu_A`
      \mu_{TA}`
      \mu_A`
      \mu_A]
    \efig
    & \quad &
    \bfig
    \qtriangle|amm|/->`=`->/[
      TA`
      T^2A`
      TA;
      \eta_{TA}``
      \mu_A]
    \btriangle|mma|/->`=`->/[
      TA`
      T^2A`
      TA;
      T\eta_A``
      \mu_A]
    \efig
  \end{array}
  \]
\end{definition}
From a computational perspective one should think of an object $A$ as
being the type of values, and the object $TA$ as the type of
computations.  Then $\eta_A : A \mto TA$ says that all values are
computations that eventually yield a value of type $A$, and $\mu_A :
T^2A \mto TA$ says forming the type of computations that eventually
yield a computation of type $TA$ is just as good as a computation of
type $TA$.  We can also think of $TA$ as capturing all of the possible
computations where $T^2A$ really does not add anything new.  We will
see that join allows for a very interesting form of composition to be
defined.

The diagrams above tell us how $\eta$ and $\mu$ interact together.
For example, inserting a computation of type $TA$ into the type of
computations of type $T^2A$, and then joining $T^2A$ to yield $TA$
does not do anything to the input.  That is, $\eta_{TA};\mu_A =
\id_{TA}$.  These diagrams will ensure that program evaluation behaves
correctly in the model.

Consider an example.  The functor $\mathcal{P} : \mathsf{Set} \mto
\mathsf{Set}$ defined as $\mathcal{P}(X) = \{S \subseteq X\}$.  First,
we need to check to make sure this is an endofunctor so suppose $f : A
\mto B$ is a function, then we can define $\mathcal{P}(f)(X \subseteq
A) = \{f(x) \mid x \in X \} : \mathcal{P}(A) \mto
\mathcal{P}(B)$. Suppose $f : A \mto B$ and $g : B \mto C$.  Then
composition is preserved $\mathcal{P}(f;g) =
\mathcal{P}(f);\mathcal{P}(g) : \mathcal{P}(A) \mto \mathcal{P}(C)$.  We
can also see that $\mathcal{P}(\id_A) =
\id_{\mathcal{P}(A)} : \mathcal{P}(A) \mto \mathcal{P}(A)$.

It turns out that this functor is indeed a monad:
\[
\begin{array}{lll}
  \eta_A(x) = \{x\} : A \mto \mathcal{P}(X)\\
  \mu_A(X) = \bigcup_{S \in X}S : \mathcal{P}(\mathcal{P}(A)) \mto \mathcal{P}(A)\\
\end{array}
\]
Now we must verify that the diagrams for a monad commute:
\[
\begin{array}{ccc}
  \bfig
  \Square|amma|[
    \mathcal{P}^3 (A)`
    \mathcal{P}^2(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \mathcal{P}\mu_A`
    \mu_{\mathcal{P}(A)}`
    \mu_A`
    \mu_A]
  \efig
  & \quad &
  \bfig
  \qtriangle|amm|/->`=`->/[
    \mathcal{P}(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \eta_{\mathcal{P}(A)}``
    \mu_A]
  \btriangle|mma|/->`=`->/[
    \mathcal{P}(A)`
    \mathcal{P}^2(A)`
    \mathcal{P}(A);
    \mathcal{P}\eta_A``
    \mu_A]
  \efig
\end{array}
\]
Using diagram chasing\footnote{Chasing an element in $\mathcal{P}(A)$
  across the top path, and then across the bottom path should echo
  back what we started with.} it is easy to see that the diagrams on
the right commute.  The left most diagram commutes by the following
equational reasoning:
\[
\begin{array}{lll}
  \mu_{A}(\mathcal{P}(\mu_A)(S \in \mathcal{P}^3(A)))
  & = & \mu_{A}(\{\mu_A(S') \mid S' \in S\})\\
  & = & \bigcup_{S'' \in (\{\mu_A(S') \mid S' \in S\})} S''\\
  & = & \bigcup_{S''' \in \bigcup_{S'' \in S} S''}S'''\\
  & = & \bigcup_{S''' \in \mu_{\mathcal{P}(A)}(S)}S'''\\
  & = & \mu_{A}(\mu_{\mathcal{P}(A)}(S))\\
\end{array}
\]
Note that in addition to the previous diagrams we would also need to
show that $\eta$ and $\mu$ are natural transformations, but we leave
this to the reader. Functions with a type of the form $A \mto
\mathcal{P}(B)$ have a special place in computer science, because they
model non-determinism.
% section what_is_a_monad_really (end)

\section{Jumping inside a monad}
\label{sec:jumping_inside_a_monad}

Suppose $(T : \cat{C} \mto \cat{C},\eta,\mu)$ is a monad.  Then we can
think of $\cat{C}$ as the pure world, and the world inside $T$ as the
impure world, or the universe of computations.  Given such a monad can
we define exactly what this impure world is?  In turns out we can by
constructing the underlying category of the monad.  There happens to
be two such categories, but they are related.

\subsection{The Kleisli category}
\label{subsec:the_kleisli_category}
Suppose we have a monad $(T,\eta,\mu)$ on some category $\cat{C}$.
The \textbf{Kleisli category} of the monad $T$ is denoted $\cat{C}_T$.
The objects of $\cat{C}_T$ are the objects of $\cat{C}$, and the
morphisms of $\cat{C}_T$ from an object $A$ to an object $B$ are the
morphisms of $\cat{C}$ from $A$ to $TB$.  That is, $\cat{C}_T(A,B) =
\cat{C}(A,TB)$.  We will denote the morphisms in $\cat{C}_T$ as
$\hat{f}$.

Before we can do anything we must first show that $\cat{C}_T$ is
indeed a category.
\begin{lemma}
  \label{lemma:Kleisli_is_a_category}
  Suppose $(T,\eta,\mu)$ is a monad on $\cat{C}$.  Then the Kleisli
  construction $\cat{C}_T$ is a category.
\end{lemma}
\begin{proof}
  Suppose $f : A \mto TB$ is a morphism.  Then the \textbf{Kleisli
    lifting} of $f$ is the morphism $\overline{f}$:
  \[ 
  \bfig
  \qtriangle[
    TA`
    T^2B`
    TB;
    Tf`
    \overline{f}`
    \mu_B]
  \efig
  \]
  \noindent
  \textbf{Composition.} Suppose $\hat{f} : A \mto B$ and $\hat{g} : B
  \mto C$ are two morphisms in $\cat{C}_T$.  These are equivalent to
  the morphisms $f : A \mto TB$ and $g : B \mto TC$ in $\cat{C}$.
  Then their composition, $\hat{f};\hat{g} : A \mto C$ in $\cat{C}_T$
  is defined by $f;\overline{g}$ in $\cat{C}$.  Thus, composition in
  $\cat{C}_T$ is composition in $\cat{C}$ where the second morphism is
  lifted.

  We have to prove that this composition is associative.  Suppose
  $\hat{f} : A \mto B$, $\hat{g} : B \mto C$, and $\hat{h} : C \mto D$
  are morphisms of $\cat{C}_T$.  These are all equivalent to $f : A
  \mto TB$, $g : B \mto TC$, and $h : C \mto TD$ from $\cat{C}$.

  \ \\
  \noindent
  It suffices to show that:
  \[
  (f;\overline{g});\overline{h} = f;\overline{(g;\overline{h})}
  \]  
  We can prove this by showing that the following diagram commutes:
  \[
  \bfig
  \square|amma|/->`->``->/<800,1000>[
    A`
    TB`
    TB`
    T^2C;
    f`
    f``
    Tg]
  \square(800,0)|amma|/->``->`->/<800,1000>[
    TB`
    T^2C`
    T^2C`
    T^3D;
    Tg``
    T^2h`
    T^2h]
  \square(1600,0)|amma|/->`->``->/<800,1000>[
    T^2C`
    TC`
    T^3D`
    T^2D;
    \mu_C`
    T^2h``
    T\mu_D]
  \square(2400,0)|amma|/->``->`->/<800,1000>[
    TC`
    T^2D`
    T^2D`
    TD;
    Th``
    \mu_D`
    \mu_D]
  \Atriangle(1600,0)/<-`->`/<800,500>[
    T^2D`
    T^3D`
    TD;
    \mu_{TD}`
    \mu_D`]
  \morphism(2400,1000)|m|<0,-500>[
    TC`
    T^2D;
    Th]
  \efig
  \]
  The left square trivially commutes, the left-most upper-right square
  commutes by naturality of $\mu$, the right-most upper-right square
  trivially commutes, and the right-lower triangle commutes by the
  monad laws.

  \ \\
  \noindent
  \textbf{Identities.} Suppose $A$ is an object of $\cat{C}_T$.  Then
  we need to show there there exists a morphism $\hat{\id}_A : A \mto
  A$ such that for any morphism $\hat{f} : A \mto B$ we have
  $\hat{\id}_A;\hat{f} = \hat{f} = \hat{f};\hat{\id_B}$.  The only
  option we have is $\eta_A : A \mto TA$, because it is the only
  morphism from $\cat{C}$ with the required form that we know always
  exists.  Thus, $\hat{\id}_A = \eta_A$.  The following commutative
  diagrams imply our desired property:
  \[
  \begin{array}{lll}
    \bfig
    \Vtrianglepair/->`->`->``->/<500,500>[
      A`
      TB`
      T^2B`
      TB;
      f`
      \eta_{TA}`
      f``
      \mu_B]
    \Atriangle(0,500)/<-`->`/<500,500>[
      TA`
      A`
      T^2B;
      \eta_A`
      Tf`]
    \morphism(500,500)/=/<0,-500>[
      TB`
      TB;]
    \efig
    & \quad &
    \bfig
    \Vtrianglepair/->`->`->``->/<500,500>[
      A`
      TB`
      T^2B`
      TB;
      f`
      T\eta_B`
      f``
      \mu_B]
    \morphism(500,500)/=/<0,-500>[
      TB`
      TB;]
    \efig
  \end{array}
  \]  
  The left diagram commutes, because the upper triangle commutes by
  naturality of $\eta$, and the lower-left triangle commutes by the
  monad laws. The right diagram commutes, because the right-most
  diagram commutes by the monad laws.
\end{proof}

Notice that the previous proof explicitly defines the notion of
Kleisli lifting of a morphism.  The astute reader will notice that we
have seen this before.  Consider monads from a functional programming
perspective, we can see that \verb!return : A -> m A! corresponds to
$\eta_A : A \mto TA$, but what does bind,
\verb!>>= :: m b -> (b -> m c) -> m c!, correspond to?  Surely it is
not $\mu_A : T^2A \mto TA$.  Consider the following equivalent form of
bind obtained by currying:
\[
\verb!>>= :: (b -> m c) -> (m b -> m c)!
\]
This looks a lot like the Kleisli lifting:
\[
\mathsf{Hom}_{\cat{C}}(B,TC) \mto \mathsf{Hom}_{\cat{C}}(TB,TC)
\]
In fact, it is!  One of the most important realizations that Moggi had
was that programming in a monad amounts to programming in the Kleisli
category of the monad.  As we can see \verb!bind! and $\mu$ are not
completely unrelated, and one can actually define each of them in
terms of the other.  So monads could be defined in terms of bind and
then we could derive $\mu$, but we leave the details to the reader.
% subsection the_kleisli_category (end)

\subsection{The Eilenberg-Moore category}
\label{subsec:the_eilenberg-moore_category}
A second more general category that corresponds to the universe inside
of a monad is called the Eilenberg-Moore category.  Suppose $(T,
\eta,\delta)$ is a monad on the category $\cat{C}$.  Then a
\textbf{$T$-algebra} is a pair $(A,h_A)$ of an object $A$ of $\cat{C}$
and a morphism, called the structure map, $h_A : TA \mto A$ such that
the following diagrams commute:
\[
\begin{array}{lll}
  \bfig
\square|amma|<700,500>[
  T^2A`
  TA`
  TA`
  A;
  Th_A`
  \mu_A`
  h_A`
  h_A]
\efig
& \quad &
\bfig
\qtriangle|amm|/->`=`->/[
  A`
  TA`
  A;
  \eta_A``
  h_A]
\efig
\end{array}
\]
A morphism $f : (A,h_A) \mto (B,h_B)$ between $T$-algebras is a
morphism $f : A \mto B$ of $\cat{C}$ such that the following diagram
commutes:
\[
\bfig
\square|amma|<700,500>[
  TA`
  TB`
  A`
  B;
  Tf`
  h_A`
  h_B`
  f]
\efig
\]
The \textbf{Eilenberg-Moore category} $\cat{C}^T$ of a monad
$(T,\eta,\mu)$ has as objects all the $T$-algebras and as morphisms
all of the $T$-algebras morphisms.  The categorical structure of
$\cat{C}^T$ is inherited from the underlying category $\cat{C}$ as the
following result shows.
\begin{lemma}
  \label{lemma:EMC-is-cat}
  Suppose $(T,\eta,\mu)$ is a monad on a category $\cat{C}$.  Then
  $\cat{C}^T$ is a category.
\end{lemma}
\begin{proof}
  Suppose $(T,\eta,\mu)$ is a monad on a category $\cat{C}$.

  \ \\
  \noindent
  \textbf{Composition.}  Suppose $f : (A,h_A) \mto (B,h_B)$ and $g :
  (B,h_B) \mto (C,h_C)$ are two $T$-algebra morphisms.  The
  composition $f;g : A \mto C$ is a $T$-algebra morphism between
  $T$-algebras $(A,h_A)$ and $(C,h_C)$ because the following diagram
  commutes:
  \[
  \bfig
  \square|amma|<700,500>[
    TA`
    TB`
    A`
    B;
    Tf`
    h_A`
    h_B`
    f]
    \square(700,0)|amma|<700,500>[
    TB`
    TC`
    B`
    C;
    Tg`
    h_B`
    h_C`
    g]
  \efig
  \]
  Each square commutes by the respective diagram for each morphism.
  Associativity holds trivially, because it holds in $\cat{C}$.

  \ \\
  \noindent
  \textbf{Identities.} Given a $T$-algebra, $(A,h_A)$, we must define
  an identity morphism $\id : (A,h_A) \mto (A,h_A)$, but we can simply
  take $\id_A : A \mto A$ as this morphism, because the following
  diagram commutes:
  \[
  \bfig
  \square<700,500>[
    TA`
    TA`
    A`
    A;
    T\id_A`
    h_A`
    h_A`
    \id_A]
  \efig
  \]
  This diagram commutes, because we know $T\id_A = \id_{TA}$, because
  $T$ is an endofunctor on $\cat{C}$.  Composition will respect
  identities, because composition in $\cat{C}$ does.
\end{proof}

The Eilenberg-Moore category is related to the Kleisli category in the
following way.  Define the category $\mathsf{Free}(\cat{C}^T)$ to be
the full subcategory of $\cat{C}^T$ with objects the free $T$-algebras
of the form $(TA,\mu_A)$ the diagram making this a $T$-algebra is the
monad law for $\mu$. Morphisms in $\mathsf{Free}(\cat{C}^T)$ are all
the $T$-algebras morphisms between free $T$-algebras.
\begin{lemma}
  \label{lemma:the_kleisli_category_is_a_full_subcategory_of_the_eilenberg-moore_category}
  Suppose $(T,\eta,\mu)$ is a monad on the category $\cat{C}$.  Then
  the category $\cat{C}_T$ is a full subcategory of $\cat{C}^T$.
\end{lemma}
\begin{proof}
  The full proof of this is out of scope of this short lecture note,
  but it is possible to show that $\cat{C}_T$ is equivalent to
  $\mathsf{Free}(\cat{C}^T)$, and hence, we obtain our result.
\end{proof}

The benefit of the Eilenberg-Moore category is that it is often easier
to prove properties about it than the Kleisli category.  Since the
Kleisli category is a full subcategory of the Eilenberg-Moore category
any property that holds on the Eilenberg-Moore category also holds for
the Kleisli category.  
% subsection the_eilenberg-moore_category (end)

% section jumping_inside_a_monad (end)

\section{Categorical Model of $\lambda_T$}
\label{sec:categorical_model_of_lambdaT}

At this point we have introduced the basics of monads categorically.
In this section we show how to categorically model a simple type
theory with monads called $\lambda_T$.  We can view $\lambda_T$ as the
smallest typed functional programming language with monads, but by
extending this language with more features one can study monads
incrementally.

The syntax for $\lambda_T$ is as follows:
\[
\small
\begin{array}{lll}
  \text{(types)}  & [[A]],[[B]],[[C]] := [[1]] \mid [[T A]] \mid [[A x B]] \mid [[A -> B]]\\
  \text{(terms)} & [[t]] := [[x]] \mid [[triv]] \mid [[(t1,t2)]] \mid [[fst t]] \mid [[snd t]] \mid [[\x:A.t]] \mid [[t1 t2]] \mid [[return t]] \mid [[let x <- t1 in t2]]\\
  \text{(contexts)} & [[G]] := [[.]] \mid [[x : A]] \mid [[G1,G2]]
\end{array}
\]
We can see that this is an extension of the simply typed
$\lambda$-calculus.  We add a new type $[[T A]]$ which represents an
arbitrary monad, and new terms for return and bind denoted $[[return
    t]]$ an $[[let x <- t1 in t2]]$ respectively.  This language is
very similar to Moggi's metalanguage \cite{Moggi:1988}.

The typing rules for $\lambda_T$ can be found in
Figure~\ref{fig:lambdaT-typing}, and the reduction rules are in
Figure~\ref{fig:lambdaT-eval}.
\begin{figure}
  \begin{mathpar}
    \Ottdrulevar{} \and
    \Ottdruletriv{} \and
    \Ottdrulepair{} \and
    \Ottdrulefirst{} \and
    \Ottdrulesecond{} \and
    \Ottdrulelambda{} \and
    \Ottdruleapp{} \and
    \Ottdrulereturn{} \and
    \Ottdrulebind{}
  \end{mathpar}
  \caption{Typing Rules for $\lambda_T$}
  \label{fig:lambdaT-typing}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \OttdrulerXXbeta{} \and
    \OttdrulerXXfirst{} \and
    \OttdrulerXXsecond{} \and
    \OttdrulerXXbind{}
  \end{mathpar}
  \caption{Reduction Rules for $\lambda_T$}
  \label{fig:lambdaT-eval}
\end{figure}
The reduction rules are rather simplistic, but are advanced enough for
the purpose of this note.  Congruence rules are omitted in the
interest of brevity.  There are also more monadic rules that one might
one, for example a commuting conversion of bind, but we leave these
out.

The main question of this section is, what is the categorical model of
$\lambda_T$?  We know we can interpret $\lambda_T$ excluding the
monadic bits into a cartesian closed category.  Thus, the model of
full $\lambda_T$ must be some extension of a cartesian closed category
with a monad.  Is it enough to simply take a cartesian closed category
$\cat{C}$ with a monad $(T,\eta,\mu)$ on $\cat{C}$?

Suppose $(\cat{C}, 1, \times, \to)$ is a cartesian closed category,
and $(T,\eta,\mu)$ is a monad on $\cat{C}$.  Types are interpreted
into this model as follows:
\[
\begin{array}{lll}
  [[ [1] ]] & = & 1\\
  [[ [A x B] ]] & = & [[ [A] x [B] ]]\\
  [[ [A -> B] ]] & = & [[ [A] -> [B] ]]\\
  [[ [T A] ]] & = & [[ T [A] ]]
\end{array}
\]
Contexts $\Gamma = [[x1 : A1]],\ldots,[[xi : Ai]]$ will be interpreted
into $\cat{C}$ by $[[ [G] ]] = [[ [A1] ]] \times \cdots \times [[ [ Ai
] ]]$.  To make the syntax less cluttered we will drop the
interpretation brackets from the interpretation of types.

We will interpret each typing judgment $[[G |- t : A]]$ as a morphism
$[[ [G] ]] \mto^{[[ [t] ]]} [[ [A] ]]$ by induction on the form of the
typing judgment. Now consider the two monadic typing rules:
\[
\begin{array}{lll}
  \Ottdrulereturn{} & \quad & \Ottdrulebind{}
\end{array}
\]
Consider the left rule, and suppose we have a morphism $t : [[G]] \mto
[[A]]$ in $\cat{C}$.  Then we must construct a morphism of the form
$[[G]] \mto [[T A]]$, but this is easily done by $t;\eta_A : [[G]]
\mto [[T A]]$.  Thus, the interpretation of $[[ [return t] ]]$ is
$[[ [t] ]];\eta_A$.

Now consider the rule $T_e$, and suppose we have morphisms $[[t1]] :
[[G]] \mto [[T A]]$ and $[[t2]] : [[G]] \times [[A]] \mto [[T B]]$.
We are expecting to Kleisli lift $[[t2]]$ to $\overline{t_2} = [[(T
    t2)]];\mu_B : T ([[G]] \times [[A]]) \mto T [[B]]$, and then
compose $\langle \id_{[[G]]} , [[t1]] \rangle : [[G]] \mto [[G]]
\times [[T A]]$ with $\overline{t_2}$, but the types do not match!  If
we had a natural transformation $\mathsf{st}_{A,B} : A \times T B \mto
T(A \times B)$ then we could finish the job by interpreting
$[[G |- let x <- t1 in t2 : T B]]$ by
$\langle \id_{[[G]]} , [[t1]] \rangle;\mathsf{st}_{[[G]],[[A]]};\overline{t_2} : [[G]] \mto [[T B]]$.
Therefore, an arbitrary monad does not have enough structure to model
the bind rule in the presence of multiple hypotheses.  Instead we need
a strong monad.

\begin{definition}
  \label{def:strong-monad}
  A monad $(T,\eta,\mu)$ on a category $\cat{C}$ with all finite
  products is \textbf{strong} if there exists a natural transformation
  $\mathsf{st}_{A,B} : A \times T B \mto T(A \times B)$ called the
  \textbf{tensorial strength} of the monad.  In addition, the following
  diagrams must commute:
  \begin{center}
    \begin{math}
      \begin{array}{ccc}
        \bfig
    \qtriangle|amm|<700,500>[
      1 \times TA`
      T(1 \times A)`
      TA;
      \mathsf{st}_{1,A}`
      \rho_{TA}`
      T\rho_A]
    \efig
    & \quad & 
    \bfig
    \btriangle|maa|/<-``->/<800,500>[
      A \times TB`
      A \times T^2 B`
      T(A \times TB);
      \id_A \times \mu_B``
      \mathsf{st}_{A,TB}]

    \dtriangle(800,0)|ama|/`<-`->/<800,500>[
      T(A \times B)`
      T(A \times TB)`
      T^2(A \times B);`
      \mu_{A \times B}`
      T\mathsf{st}_{A,B}]
  
    \Atriangle(0,500)|mma|<800,300>[
      A \times B`
      A \times TB`
      T(A \times B);
      \id_A \times \eta_B`
      \eta_{A \times B}`
      \mathsf{st}_{A,B}]
    \efig
      \end{array}
    \end{math}
  \end{center}
  \begin{mathpar}       
    \bfig
    \square|amma|/`->``->/<1000,500>[
      (A \times B) \times C``
      A \times (B \times C)`
      A \times T(B \times C);`
      \alpha_{A,B,C}``
      \id_A \times \mathsf{st}_{B,C}]
    \morphism(1000,0)<1200,0>[
      A \times T(B \times C)`
      T(A \times T(B \times C));
      \mathsf{st}_{A,B \times C}]
    \morphism(0,500)<2200,0>[
      (A \times B) \times C`
      T((A \times B) \times C);
      \mathsf{st}_{A \times B,C}]
    \morphism(2200,500)|m|<0,-500>[
      T((A \times B) \times C)`
      T(A \times T(B \times C));
      T\alpha_{A,B,C}]
    \efig
  \end{mathpar}
\end{definition}
Adopting strong monads instead of arbitrary ones yields a sound and
complete model.
\begin{definition}
  \label{def:lambdaT-model}
  A \textbf{$\lambda_T$ model} consists of a cartesian closed category
  $\cat{C}$ equipped with a strong monad $(T,\eta,\mu)$ on $\cat{C}$.
\end{definition}
\noindent
Finally, we have the following:
\begin{theorem}[Soundness]
  \label{thm:soundness}
  Suppose $(T : \cat{C} \mto \cat{C},\eta,\mu)$ is a $\lambda_T$ model.  Then if $[[G |- t1 :
      A]]$ and $[[t1 ~> t2]]$, the $[[ [t1] ]] \cong [[ [t2] ]] : [[ [G] ]] \mto [[ [A] ]]$ in $\cat{C}$.
\end{theorem}


% section categorical_model_of_lambdaT (end)


%% \section{Monads are modular, right?}
%% \label{sec:monads_are_modular,_right?}

%% % section monads_are_modular,_right? (end)


\bibliographystyle{plain} \bibliography{references}

\end{document}

